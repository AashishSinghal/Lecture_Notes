
## Disjoint Set Union

Disjoint Set Union is one of the simplest and easy to implement data structure, which is used to keep track of disjoint(Non-overlapping) dynamic sets.

![enter image description here](https://lh3.googleusercontent.com/0_ODdLNCGwS5fJNoV_7_dv-yOcgpqpsoqNZg5pdXY1Ms6cTV8xUFMCORIc3ywty57Dal29hCOULw)

In the image above, $\{a,b,c,d\}$ and $\{e,f\}$ are two non-overlapping(disjoint) sets. Dynamic here means that we can combine any two sets, so they are dynamic.

**Note:** Here disjoint set is represented as a tree and terminology of tree is used.

There are three main operations of this data structure: Make-set, Find and Union

 1. **Make-Set**: This operation creates a disjoint set having a single element.

 2. **Find**: This operation finds a unique set to which a particular element belongs.

 3. **Union**: This operation unifies two disjoint sets.

There are many ways we can implement this data structure: Linked list, Array, Trees. But here we will implement using array and represent using tree.

**Some Terminologies**

 - **Parent** is a main attribute of an element which represents an element by which a particular element is connected with some disjoint set.
In the image below, $c$ is parent of $d$ and $a$ is parent of $c$.

![enter image description here](https://lh3.googleusercontent.com/iaVsRRMUzGUK-PlEl7gFtUoDnatg9O2tBF-gMJ_qm5FyNWJSWXnCL6jAxX5siijx1L57Tg-3A0HZ)

 - **Root** is an element of a set whose parent is itself. It is unique per set. 
$a$ is the root element for the left disjoint set.


## Operation Make-Set

Make-Set operation creates a new set having a single element (means $size=1$) which is having a unique id.

**Pseudocode:**
```	
MAKE-SET(x)
{
	x.parent = x;
	x.size = 1;
}
```
Here X is the only element in the set so it is parent of itself.

The image below represents sets generated by this operation. Where each one having arrow coming to itself, which represents that it is its own parent right now. Each one have size of 1.
![enter image description here](https://lh3.googleusercontent.com/UW-R9Hbi7YaCOyrVd2F0ThzzQ9pAF1zqoASJDhGKjbBHN8P-dJJr4sZubW1csc97l6iQMo3L39Bc)

We are working with arrays, so the code to make $n$ sets is as below:

```c++
vector<int> parent,size;
void Make_sets(int n)
{
	parent.resize(n);
	size.resize(n);
	for(int i = 0; i < n; i++)
	{
		parent[i] = i;
		size[i] = 1;
	}
}
```

**Time Complexity:** Make-Set operation take $O(1)$ time. So creating $N$ sets it will take $O(N)$ time.

## Operation Find

$\text{Find}(X)$ basically finds the root element of the disjoint set to which $X$ belongs. 

If we apply $\text{Find}(d)$ or $\text{Find}(c)$ operation for the set in the image below, then it will return '$a$' which is a root element.

![enter image description here](https://lh3.googleusercontent.com/j1H9MBKoSzyQV_8ObjBOjD1W2Na57kYg8aGMrbI8dLepF2IIqbRJSKzccH7rgfWrBqgFJ3LtYzAN)

Here the thing to note is that, the root element of a root element of any disjoint set is itself i.e., $root.parent = root$

**Algorithm**

Until you reach at the root element, traverse the tree of the disjoint set upwards.

**Pseudocode:**
```
FIND(X)
	while x != x.parent
		x = x.parent
		
	return x;
```
**Visualization**
![enter image description here](https://lh3.googleusercontent.com/ex1uHjYzU0MXu0auog7GwQsAbawGVSROIvn0COglh33LHbHYFc8sTHnkn3Qgjb1FgJIaeLOz8Qig)

---------------
### Quiz Time

Can you find the recursive implementation of the above function?

Answer:
```
FIND(x)
	if x == x.parent
		return x
	else
		return FIND(x.parent) 
```
------------------

**Implementation in C++**
```c++
// Iterative implementation
int Find(x)
{
	while(x != parent[x])
		x = parent[x];
	return x;
}

// Recursive implementation
int Find(x)
{
	if(x == parent[x])
		return x;
	else
		return Find(parent[x]);
}
```
**Time Complexity:** This operation can take $O(N)$ in worst case where N is the size of the set-which can be number of total elements at maximum.

This is too much. Right? What else can we do?

We have a technique named **"Path compression"**, which burns this time to $O(log^*N)$. $log^*N$ is iterated logarithm-number of time you have to apply $log$ to $N$ before the result is less than or equal to 1.

The idea of the Path compression is: **It re-connects every vertex to the root vertex directly, rather than by a path**.

If we apply $\text{Find}(d)$ operation with the path compression, then the following thing will happen.
![enter image description here](https://lh3.googleusercontent.com/ltQXkpZAjEO543ibrVodpMMZp2IHXVJ7Rjxevm2ztJQAC67UnvBeMmwEoIB9qZ0_2PgpSs98nWV9)

How can we do it? It is easy, we just need a little modification in $\text{Find}(X)$.

**Pseudocode:**
```
FIND(x)
	if x == x.parent
		return x
	else 
		x.parent = FIND(x.parent);
		return x.parent
```
So every time we run this function, it will re-connect every vertex on the path to the root, directly to the root.

---
### Quiz Time

Can you write the iterative version of the above $\text{FIND}(X)$ function with path compression?

Answer:
```
FIND(x)
	y = x

	while y != y.parent
		y = y.parent
	
	while x != x.parent
		z = x.parent;
		x.parent = y
		x = z
		
```
----

**Implementation in C++**
```c++
// Iterative Implementation
int Find(x)
{
	int y = x;
	while(y != parent[y])
		y = parent[y];
	
	int parent;
	
	while(x != parent[x])
	{
		parent = parent[x];
		parent[x] = y;
		x = parent;
	}
	
	return x;
}

// Recursive implementation
int Find(x)
{
	if(x == parent[x])
		return x;
	else
		return parent[x] = Find(parent[x]);
}
```

## Operation Union

$Union(X,Y)$ operation first of all finds root element of both the disjoint sets containing X and Y respectively. Then it connects the root element of one of the disjoint set to the another.

Well, how do we decide which root will connet to which? If we do it randomly then it may increase the tree height up to $O(N)$, which means that the next $Find(x)$ operation will take $O(N)$ time. Can we do better?

Yes, we have two standard techniques: **By size and By rank**.

### By Size
Union by size technique decides it based on the sizes of the sets. Everytime, the smaller size set is attatched to the larger size set.

![enter image description here](https://lh3.googleusercontent.com/O9Q-Sbfm2LvjdbEgVoUwWSVfs4vA9MLxCgNGuzOWiyWgE_j9O2NOgTmOrhlZb5QMI_nPgG5lDfIo)

**Note:** The numbers in square bracket represents the size of the set below it.

**Pseudocode:**
```
UNION(X,Y)
	Rx = FIND(X), Ry = FIND(Y)

	if Rx == Ry
		return
	if Rx.size > Ry.size
		Ry.parent = Rx
		Rx.size = Rx.size + Ry.size
	else 
		Rx.parent = Ry
		Ry.size = Ry.size + Rx.size
```

### By Rank
In Union by rank technique, shorter tree is attatched to taller tree. Initally rank of each disjoint set is zero. 

If both sets have same rank, then the resulting rank will be one greater. Otherwise the resulting rank will be larger of the two.

**Note:** In the image below, the numbers in square bracket represents the rank of the set below it.

Example 1:

![enter image description here](https://lh3.googleusercontent.com/6DjycKp_SUVdInkEVhT89_v_YcblSZAyHZaAxiAI60MN81f9ZNIZW2G0UjivAW2AIwDuH6z0EF0V)
Example 2:
![enter image description here](https://lh3.googleusercontent.com/_q-grBb90uOEu9v2EH1TXsHcHZh6QtyBRroxDiLch0vMdzLPvcvTd_YGoRa85fZYTMG_Qo_JDxOl)

**Pseudocode:**
```
UNION(X,Y)
	Rx = FIND(X), Ry = FIND(Y)

	if Rx == Ry
		return
	if Rx.rank > Ry.rank
		Ry.parent = Rx
		if Rx.rank == Ry.rank
			Rx.rank = Rx.rank + 1
	else 
		Rx.parent = Ry
		if Rx.rank == Ry.rank
			Ry.rank = Ry.rank + 1
```

**Implementation in c++**
```c++
// By size
void union(int x,int y)
{
	int Rx = find(x), Ry = find(y);
	
	if(Rx == Ry)
		return;
		
	if(size[Ry] > size[Rx])
		swap(Rx,Ry);
	
	parent[Ry] = Rx;
	size[Rx] += size[Ry];
		
}

// By Rank
void union(int x,int y)
{
	int Rx = find(x), Ry = find(y);
	
	if(Rx == Ry)
		return;
		
	if(rank[Ry] > rank[Rx])
		swap(Rx,Ry);
	
	parent[Ry] = Rx;
	
	if(rank[Rx] == rank[Ry])
		rank[Rx] += 1;

}
```

### Time Complexity of Union

 1. Without path compression: $O(N)$
 2. With path compression: $O(log^*N)$

## Applications of DSU

 1. To keep track of connected components in an undirected graph.
 2. In Kruskal's and Boruvka's algorithm to find minimum spanning tree.
